### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type AggregateCoreCompetency {
  count: Int!
}

type AggregateJournalClub {
  count: Int!
}

type AggregateOverallCompetency {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AuthPayload {
  token: String!
  user: User!
}

type BatchPayload {
  count: Long!
}

enum Core {
  ACHIEVED
  NEEDS_IMPROVEMENT
  NOT_APPLICABLE
  SATISFACTORY_PROGRESS
}

type CoreCompetency {
  comment: String
  competency: Core!
  id: ID!
}

type CoreCompetencyConnection {
  aggregate: AggregateCoreCompetency!
  edges: [CoreCompetencyEdge!]!
  pageInfo: PageInfo!
}

input CoreCompetencyCreateInput {
  comment: String
  competency: Core!
  id: ID
}

input CoreCompetencyCreateOneInput {
  connect: CoreCompetencyWhereUniqueInput
  create: CoreCompetencyCreateInput
}

type CoreCompetencyEdge {
  cursor: String!
  node: CoreCompetency!
}

enum CoreCompetencyOrderByInput {
  comment_ASC
  comment_DESC
  competency_ASC
  competency_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input CoreCompetencyUpdateDataInput {
  comment: String
  competency: Core
}

input CoreCompetencyUpdateInput {
  comment: String
  competency: Core
}

input CoreCompetencyUpdateManyMutationInput {
  comment: String
  competency: Core
}

input CoreCompetencyUpdateOneRequiredInput {
  connect: CoreCompetencyWhereUniqueInput
  create: CoreCompetencyCreateInput
  update: CoreCompetencyUpdateDataInput
  upsert: CoreCompetencyUpsertNestedInput
}

input CoreCompetencyUpsertNestedInput {
  create: CoreCompetencyCreateInput!
  update: CoreCompetencyUpdateDataInput!
}

input CoreCompetencyWhereInput {
  AND: [CoreCompetencyWhereInput!]
  comment: String
  comment_contains: String
  comment_ends_with: String
  comment_gt: String
  comment_gte: String
  comment_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_not: String
  comment_not_contains: String
  comment_not_ends_with: String
  comment_not_in: [String!]
  comment_not_starts_with: String
  comment_starts_with: String
  competency: Core
  competency_in: [Core!]
  competency_not: Core
  competency_not_in: [Core!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [CoreCompetencyWhereInput!]
  OR: [CoreCompetencyWhereInput!]
}

input CoreCompetencyWhereUniqueInput {
  id: ID
}

scalar DateTime

type JournalClub {
  analysis: CoreCompetency!
  application: CoreCompetency!
  article: String!
  audienceEngagement: CoreCompetency!
  background: CoreCompetency!
  clarity: CoreCompetency!
  conclusions: CoreCompetency!
  createdAt: DateTime!
  evaluator: User!
  grammar: CoreCompetency!
  id: ID!
  knowsAudience: CoreCompetency!
  methods: CoreCompetency!
  organization: CoreCompetency!
  overall: OverallCompetency!
  preceptor: User!
  resident: User!
  responseToQuestions: CoreCompetency!
  results: CoreCompetency!
  understanding: CoreCompetency!
  updatedAt: DateTime!
}

type JournalClubConnection {
  aggregate: AggregateJournalClub!
  edges: [JournalClubEdge!]!
  pageInfo: PageInfo!
}

input JournalClubCreateInput {
  analysis: CoreCompetencyCreateOneInput!
  application: CoreCompetencyCreateOneInput!
  article: String!
  audienceEngagement: CoreCompetencyCreateOneInput!
  background: CoreCompetencyCreateOneInput!
  clarity: CoreCompetencyCreateOneInput!
  conclusions: CoreCompetencyCreateOneInput!
  evaluator: UserCreateOneInput!
  grammar: CoreCompetencyCreateOneInput!
  id: ID
  knowsAudience: CoreCompetencyCreateOneInput!
  methods: CoreCompetencyCreateOneInput!
  organization: CoreCompetencyCreateOneInput!
  overall: OverallCompetencyCreateOneInput!
  preceptor: UserCreateOneInput!
  resident: UserCreateOneInput!
  responseToQuestions: CoreCompetencyCreateOneInput!
  results: CoreCompetencyCreateOneInput!
  understanding: CoreCompetencyCreateOneInput!
}

type JournalClubEdge {
  cursor: String!
  node: JournalClub!
}

enum JournalClubOrderByInput {
  article_ASC
  article_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input JournalClubUpdateInput {
  analysis: CoreCompetencyUpdateOneRequiredInput
  application: CoreCompetencyUpdateOneRequiredInput
  article: String
  audienceEngagement: CoreCompetencyUpdateOneRequiredInput
  background: CoreCompetencyUpdateOneRequiredInput
  clarity: CoreCompetencyUpdateOneRequiredInput
  conclusions: CoreCompetencyUpdateOneRequiredInput
  evaluator: UserUpdateOneRequiredInput
  grammar: CoreCompetencyUpdateOneRequiredInput
  knowsAudience: CoreCompetencyUpdateOneRequiredInput
  methods: CoreCompetencyUpdateOneRequiredInput
  organization: CoreCompetencyUpdateOneRequiredInput
  overall: OverallCompetencyUpdateOneRequiredInput
  preceptor: UserUpdateOneRequiredInput
  resident: UserUpdateOneRequiredInput
  responseToQuestions: CoreCompetencyUpdateOneRequiredInput
  results: CoreCompetencyUpdateOneRequiredInput
  understanding: CoreCompetencyUpdateOneRequiredInput
}

input JournalClubUpdateManyMutationInput {
  article: String
}

input JournalClubWhereInput {
  analysis: CoreCompetencyWhereInput
  AND: [JournalClubWhereInput!]
  application: CoreCompetencyWhereInput
  article: String
  article_contains: String
  article_ends_with: String
  article_gt: String
  article_gte: String
  article_in: [String!]
  article_lt: String
  article_lte: String
  article_not: String
  article_not_contains: String
  article_not_ends_with: String
  article_not_in: [String!]
  article_not_starts_with: String
  article_starts_with: String
  audienceEngagement: CoreCompetencyWhereInput
  background: CoreCompetencyWhereInput
  clarity: CoreCompetencyWhereInput
  conclusions: CoreCompetencyWhereInput
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  evaluator: UserWhereInput
  grammar: CoreCompetencyWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  knowsAudience: CoreCompetencyWhereInput
  methods: CoreCompetencyWhereInput
  NOT: [JournalClubWhereInput!]
  OR: [JournalClubWhereInput!]
  organization: CoreCompetencyWhereInput
  overall: OverallCompetencyWhereInput
  preceptor: UserWhereInput
  resident: UserWhereInput
  responseToQuestions: CoreCompetencyWhereInput
  results: CoreCompetencyWhereInput
  understanding: CoreCompetencyWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input JournalClubWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  changePassword(data: UserChangePasswordInput!): User
  confirmUser(data: UserConfirmInput!): User
  createCoreCompetency(data: CoreCompetencyCreateInput!): CoreCompetency!
  createJournalClub(data: JournalClubCreateInput!): JournalClub!
  createOverallCompetency(data: OverallCompetencyCreateInput!): OverallCompetency!
  createUser(data: UserCreateInput!): User!
  deleteCoreCompetency(where: CoreCompetencyWhereUniqueInput!): CoreCompetency
  deleteJournalClub(where: JournalClubWhereUniqueInput!): JournalClub
  deleteManyCoreCompetencies(where: CoreCompetencyWhereInput): BatchPayload!
  deleteManyJournalClubs(where: JournalClubWhereInput): BatchPayload!
  deleteManyOverallCompetencies(where: OverallCompetencyWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteOverallCompetency(where: OverallCompetencyWhereUniqueInput!): OverallCompetency
  deleteUser(where: UserWhereUniqueInput!): User
  forgotPassword(data: UserForgotPasswordInput!): Boolean
  login(data: UserLoginInput!): AuthPayload
  register(data: UserRegisterInput!): AuthPayload
  updateCoreCompetency(data: CoreCompetencyUpdateInput!, where: CoreCompetencyWhereUniqueInput!): CoreCompetency
  updateJournalClub(data: JournalClubUpdateInput!, where: JournalClubWhereUniqueInput!): JournalClub
  updateManyCoreCompetencies(data: CoreCompetencyUpdateManyMutationInput!, where: CoreCompetencyWhereInput): BatchPayload!
  updateManyJournalClubs(data: JournalClubUpdateManyMutationInput!, where: JournalClubWhereInput): BatchPayload!
  updateManyOverallCompetencies(data: OverallCompetencyUpdateManyMutationInput!, where: OverallCompetencyWhereInput): BatchPayload!
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOverallCompetency(data: OverallCompetencyUpdateInput!, where: OverallCompetencyWhereUniqueInput!): OverallCompetency
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertCoreCompetency(create: CoreCompetencyCreateInput!, update: CoreCompetencyUpdateInput!, where: CoreCompetencyWhereUniqueInput!): CoreCompetency!
  upsertJournalClub(create: JournalClubCreateInput!, update: JournalClubUpdateInput!, where: JournalClubWhereUniqueInput!): JournalClub!
  upsertOverallCompetency(create: OverallCompetencyCreateInput!, update: OverallCompetencyUpdateInput!, where: OverallCompetencyWhereUniqueInput!): OverallCompetency!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

enum Overall {
  DOES_NOT_MEET_EXPECTATIONS
  MEETS_EXPECTATIONS
}

type OverallCompetency {
  comment: String
  competency: Overall!
  id: ID!
}

type OverallCompetencyConnection {
  aggregate: AggregateOverallCompetency!
  edges: [OverallCompetencyEdge!]!
  pageInfo: PageInfo!
}

input OverallCompetencyCreateInput {
  comment: String
  competency: Overall!
  id: ID
}

input OverallCompetencyCreateOneInput {
  connect: OverallCompetencyWhereUniqueInput
  create: OverallCompetencyCreateInput
}

type OverallCompetencyEdge {
  cursor: String!
  node: OverallCompetency!
}

enum OverallCompetencyOrderByInput {
  comment_ASC
  comment_DESC
  competency_ASC
  competency_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input OverallCompetencyUpdateDataInput {
  comment: String
  competency: Overall
}

input OverallCompetencyUpdateInput {
  comment: String
  competency: Overall
}

input OverallCompetencyUpdateManyMutationInput {
  comment: String
  competency: Overall
}

input OverallCompetencyUpdateOneRequiredInput {
  connect: OverallCompetencyWhereUniqueInput
  create: OverallCompetencyCreateInput
  update: OverallCompetencyUpdateDataInput
  upsert: OverallCompetencyUpsertNestedInput
}

input OverallCompetencyUpsertNestedInput {
  create: OverallCompetencyCreateInput!
  update: OverallCompetencyUpdateDataInput!
}

input OverallCompetencyWhereInput {
  AND: [OverallCompetencyWhereInput!]
  comment: String
  comment_contains: String
  comment_ends_with: String
  comment_gt: String
  comment_gte: String
  comment_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_not: String
  comment_not_contains: String
  comment_not_ends_with: String
  comment_not_in: [String!]
  comment_not_starts_with: String
  comment_starts_with: String
  competency: Overall
  competency_in: [Overall!]
  competency_not: Overall
  competency_not_in: [Overall!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [OverallCompetencyWhereInput!]
  OR: [OverallCompetencyWhereInput!]
}

input OverallCompetencyWhereUniqueInput {
  id: ID
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum Position {
  PHARMACIST
  RESIDENT
}

type Query {
  coreCompetencies(after: String, before: String, first: Int, last: Int, orderBy: CoreCompetencyOrderByInput, skip: Int, where: CoreCompetencyWhereInput): [CoreCompetency!]!
  coreCompetenciesConnection(after: String, before: String, first: Int, last: Int, orderBy: CoreCompetencyOrderByInput, skip: Int, where: CoreCompetencyWhereInput): CoreCompetencyConnection!
  coreCompetency(where: CoreCompetencyWhereUniqueInput!): CoreCompetency
  journalClub(where: JournalClubWhereUniqueInput!): JournalClub
  journalClubs(after: String, before: String, first: Int, last: Int, orderBy: JournalClubOrderByInput, skip: Int, where: JournalClubWhereInput): [JournalClub!]!
  journalClubsConnection(after: String, before: String, first: Int, last: Int, orderBy: JournalClubOrderByInput, skip: Int, where: JournalClubWhereInput): JournalClubConnection!
  journalClubsCount(where: JournalClubWhereInput!): Int
  me: User
  overallCompetencies(after: String, before: String, first: Int, last: Int, orderBy: OverallCompetencyOrderByInput, skip: Int, where: OverallCompetencyWhereInput): [OverallCompetency!]!
  overallCompetenciesConnection(after: String, before: String, first: Int, last: Int, orderBy: OverallCompetencyOrderByInput, skip: Int, where: OverallCompetencyWhereInput): OverallCompetencyConnection!
  overallCompetency(where: OverallCompetencyWhereUniqueInput!): OverallCompetency
  user(where: UserWhereUniqueInput!): User
  users(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
  usersConnection(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): UserConnection!
}

type User {
  createdAt: DateTime!
  email: String!
  emailConfirmed: Boolean!
  firstName: String!
  fullName: String!
  id: ID!
  lastName: String!
  position: Position!
  updatedAt: DateTime!
}

input UserChangePasswordInput {
  password: String!
  token: String!
}

input UserConfirmInput {
  token: String!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  email: String!
  emailConfirmed: Boolean
  firstName: String!
  id: ID
  lastName: String!
  password: String!
  position: Position!
}

input UserCreateOneInput {
  connect: UserWhereUniqueInput
  create: UserCreateInput
}

type UserEdge {
  cursor: String!
  node: User!
}

input UserForgotPasswordInput {
  email: String!
}

input UserLoginInput {
  email: String!
  password: String!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  emailConfirmed_ASC
  emailConfirmed_DESC
  firstName_ASC
  firstName_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  password_ASC
  password_DESC
  position_ASC
  position_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserRegisterInput {
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  position: Position!
}

input UserUpdateDataInput {
  email: String
  emailConfirmed: Boolean
  firstName: String
  lastName: String
  password: String
  position: Position
}

input UserUpdateInput {
  email: String
  emailConfirmed: Boolean
  firstName: String
  lastName: String
  password: String
  position: Position
}

input UserUpdateManyMutationInput {
  email: String
  emailConfirmed: Boolean
  firstName: String
  lastName: String
  password: String
  position: Position
}

input UserUpdateOneRequiredInput {
  connect: UserWhereUniqueInput
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
}

input UserUpsertNestedInput {
  create: UserCreateInput!
  update: UserUpdateDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  emailConfirmed: Boolean
  emailConfirmed_not: Boolean
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  position: Position
  position_in: [Position!]
  position_not: Position
  position_not_in: [Position!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
